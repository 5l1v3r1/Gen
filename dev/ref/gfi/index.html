<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Generative Functions · Gen</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Gen</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../getting_started/">Getting Started</a></li><li><a class="toctext" href="../../tutorials/">Tutorials</a></li><li><span class="toctext">Language and API Reference</span><ul><li class="current"><a class="toctext" href>Generative Functions</a><ul class="internal"><li><a class="toctext" href="#Probabilistic-semantics-1">Probabilistic semantics</a></li><li><a class="toctext" href="#Execution-traces-1">Execution traces</a></li><li><a class="toctext" href="#Trace-update-methods-1">Trace update methods</a></li><li><a class="toctext" href="#Differentiable-programming-1">Differentiable programming</a></li><li><a class="toctext" href="#Trainable-parameters-1">Trainable parameters</a></li><li><a class="toctext" href="#Non-addressed-randomness-1">Non-addressed randomness</a></li></ul></li><li><a class="toctext" href="../distributions/">Probability Distributions</a></li><li><a class="toctext" href="../modeling/">Built-in Modeling Language</a></li><li><a class="toctext" href="../combinators/">Generative Functions Combinators</a></li><li><a class="toctext" href="../assignments/">Assignments</a></li><li><a class="toctext" href="../selections/">Selections</a></li><li><a class="toctext" href="../parameter_optimization/">Optimizing Trainable Parameters</a></li><li><a class="toctext" href="../inference/">Inference Library</a></li></ul></li><li><span class="toctext">Internals</span><ul><li><a class="toctext" href="../internals/parameter_optimization/">Optimizing Trainable Parameters</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Language and API Reference</li><li><a href>Generative Functions</a></li></ul><a class="edit-page" href="https://github.com/probcomp/Gen/blob/master/docs/src/ref/gfi.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Generative Functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Generative-Functions-1" href="#Generative-Functions-1">Generative Functions</a></h1><p>One of the core abstractions in Gen is the <strong>generative function</strong>. Generative functions are used to represent a variety of different types of probabilistic computations including generative models, inference models, custom proposal distributions, and variational approximations.</p><p>Generative functions are represented by the following abstact type:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.GenerativeFunction" href="#Gen.GenerativeFunction"><code>Gen.GenerativeFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">GenerativeFunction{T,U}</code></pre><p>Abstract type for a generative function with return value type T and trace type U.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/fca26a87f35b7d66b28bd6240d1fe96e38ca2fc0/src/gen_fn_interface.jl#L56-L60">source</a></section><p>There are various kinds of generative functions, which are represented by concrete subtypes of <a href="#Gen.GenerativeFunction"><code>GenerativeFunction</code></a>. For example, the <a href="../modeling/#Built-in-Modeling-Language-1">Built-in Modeling Language</a> allows generative functions to be constructed using Julia function definition syntax:</p><pre><code class="language-julia">@gen function foo(a, b)
    if @addr(bernoulli(0.5), :z)
        return a + b + 1
    else
        return a + b
    end
end</code></pre><p>Generative functions must implement the the methods of the <a href="#Generative-Function-Interface-1">Generative Function Interface</a>. Generative functions behave like Julia functions in some respects. For example, we can call a generative function <code>foo</code> on arguments and get an output value using regular Julia call syntax:</p><pre><code class="language-julia-repl">&gt;julia foo(2, 4)
7</code></pre><p>However, generative functions are distinct from Julia functions because they support additional behaviors, described in the remainder of this section.</p><h2><a class="nav-anchor" id="Probabilistic-semantics-1" href="#Probabilistic-semantics-1">Probabilistic semantics</a></h2><p>Generative functions may use randomness, but they may not mutate externally observable state. We represent the randomness used during an execution as a map from unique <strong>addresses</strong> to values, denoted <span>$t : A \to V$</span> where <span>$A$</span> is an address set and <span>$V$</span> is a set of possible values that random choices can take. In this section, we assume that random choices are discrete to simplify notation. We say that two random choice maps <span>$t$</span> and <span>$s$</span> <strong>agree</strong> if they assign the same value for all addresses that is in both of their domains. Formally, every generative function is associated with three mathematical objects:</p><h3><a class="nav-anchor" id="Input-type-1" href="#Input-type-1">Input type</a></h3><p>The set of valid argument tuples to the function, denoted <span>$X$</span>.</p><h3><a class="nav-anchor" id="Probability-distribution-family-1" href="#Probability-distribution-family-1">Probability distribution family</a></h3><p>A family of probability distributions <span>$p(t; x)$</span> on maps <span>$t$</span> from random choice addresses to their values, indexed by arguments <span>$x$</span>, for all <span>$x \in X$</span>. Note that the distribution must be normalized:</p><div>\[\sum_{t} p(t; x) = 1 \;\; \mbox{for all} \;\; x \in X\]</div><p>This corresponds to a requirement that the function terminate with probabability 1 for all valid arguments.</p><h3><a class="nav-anchor" id="Return-value-function-1" href="#Return-value-function-1">Return value function</a></h3><p>A (deterministic) function <span>$f$</span> that maps the tuple <span>$(x, t)$</span> of the arguments and the random choice map to the return value of the function (which we denote by <span>$y$</span>).</p><h3><a class="nav-anchor" id="Internal-proposal-distribution-family-1" href="#Internal-proposal-distribution-family-1">Internal proposal distribution family</a></h3><p>A family of probability distributions <span>$q(t; x, u)$</span> on maps <span>$t$</span> from random choice addresses to their values, indexed by tuples <span>$(x, u)$</span> where <span>$u$</span> is a map from random choice addresses to values, and where <span>$x$</span> are the arguments to the function. It must be normalized for all valid <span>$(x, u)$</span>:</p><div>\[\sum_{t} q(t; x, u) = 1 \;\; \mbox{for all} \;\; x \in X, u\]</div><p>Also, it must satisfy the following condition:</p><div>\[p(t; x) &gt; 0 \mbox{ if and only if } q(t; x, u) &gt; 0 \mbox{ for all } u \mbox{ where } u \mbox{ and } t \mbox{ agree }\]</div><p>Finally, we require that:</p><div>\[q(t; x, u) &gt; 0 \mbox{ implies that } u \mbox{ and } t \mbox{ agree }.\]</div><h2><a class="nav-anchor" id="Execution-traces-1" href="#Execution-traces-1">Execution traces</a></h2><p>An <strong>execution trace</strong> (or just <em>trace</em>) is a record of an execution of a generative function. There is no abstract type representing all traces. Different concrete types of generative functions use different data structures and different Jula types for their traces. The trace type that a generative function uses is the second type parameter of the <a href="#Gen.GenerativeFunction"><code>GenerativeFunction</code></a> abstract type.</p><p>A trace of a generative function can be produced using <a href="#Gen.initialize"><code>initialize</code></a>:</p><pre><code class="language-julia">(trace, weight) = initialize(foo, (2, 4))</code></pre><p>The trace contains various information about the execution, including:</p><p>The arguments to the function, which is retrieved with <a href="#Gen.get_args"><code>get_args</code></a>:</p><pre><code class="language-julia-repl">&gt;julia get_args(trace)
(2, 4)</code></pre><p>The return value of the function, which is retrieved with <a href="#Gen.get_retval"><code>get_retval</code></a>:</p><pre><code class="language-julia-repl">&gt;julia get_retval(trace)
7</code></pre><p>The map from addresses of random choices to their values, which is retrieved with <a href="#Gen.get_assmt"><code>get_assmt</code></a>, and has abstract type <a href="../assignments/#Gen.Assignment"><code>Assignment</code></a>.</p><pre><code class="language-julia-repl">&gt;julia println(get_assmt(trace))
│
└── :z : false</code></pre><p>The log probability that the random choices took the values they did for the arguments, available with <a href="#Gen.get_score"><code>get_score</code></a>:</p><pre><code class="language-julia-repl">&gt;julia get_score(trace)
-0.6931471805599453</code></pre><p>A reference to the generative function that was executed, which is retrieved with <a href="#Gen.get_gen_fn"><code>get_gen_fn</code></a>:</p><pre><code class="language-julia-repl">&gt;julia foo === get_gen_fn(trace)
true</code></pre><h2><a class="nav-anchor" id="Trace-update-methods-1" href="#Trace-update-methods-1">Trace update methods</a></h2><p>There are several methods that take a trace of a generative function as input and return a new trace of the generative function based on adjustments to the execution history of the function:</p><ul><li><a href="#Gen.force_update"><code>force_update</code></a></li><li><a href="#Gen.fix_update"><code>fix_update</code></a></li><li><a href="#Gen.free_update"><code>free_update</code></a></li><li><a href="#Gen.extend"><code>extend</code></a></li></ul><p>In addition to the input trace, and other arguments that indicate how to adjust the trace, each of these methods also accepts an <strong>args</strong> argument and an <strong>argdiff</strong> argument. The args argument contains the new arguments to the generative function, which may differ from the previous arguments to the generative function (which can be retrieved by applying <a href="#Gen.get_args"><code>get_args</code></a> to the previous trace). In many cases, the adjustment to the execution specified by the other arguments to these methods is &#39;small&#39; and only effects certain parts of the computation. Therefore, it is often possible to generate the new trace and the appropriate log probability ratios required for these methods without revisiting every state of the computation of the generative function. To enable this, the argdiff argument provides additional information about the <em>difference</em> between the previous arguments to the generative function, and the new arguments. This argdiff information permits the implementation of the update method to avoid inspecting the entire argument data structure to identify which parts were updated.</p><h2><a class="nav-anchor" id="Differentiable-programming-1" href="#Differentiable-programming-1">Differentiable programming</a></h2><p>Generative functions may support computation of gradients with respect to (i) all or a subset of its arguments, (ii) its <strong>trainable parameters</strong>, and (iii) the value of certain random choices. The set of elements (either arguments, trainable parameters, or random choices) for which gradients are available is called the <em>gradient source set</em>. A generative function statically reports whether or not it is able to compute gradients with respect to each of its arguments, through the function <code>has_argument_grads</code>. Let <span>$x_G$</span> denote the set of arguments for which the generative function does support gradient computation. Similarly, a generative function supports gradients with respect the value of random choices made at all or a subset of addresses. If the return value of the function is conditionally independent of each element in the gradient source set given the other elements in the gradient source set and values of all other random choices, for all possible traces of the function, then the generative function requires a <em>return value gradient</em> to compute gradients with respect to elements of the gradient source set. This static property of the generative function is reported by <code>accepts_output_grad</code>.</p><h2><a class="nav-anchor" id="Trainable-parameters-1" href="#Trainable-parameters-1">Trainable parameters</a></h2><h2><a class="nav-anchor" id="Non-addressed-randomness-1" href="#Non-addressed-randomness-1">Non-addressed randomness</a></h2><p>Generative functions may also use <strong>non-addressable randomness</strong>, which is not returned by <a href="#Gen.get_assmt"><code>get_assmt</code></a>. However, the state of non-addressable random choices <em>is</em> maintained by the trace internally. We denote non-addressable randomness by <span>$r$</span>. The probabilistic semantics are extended for a generative function with non-addressable randomness as follows:</p><h3><a class="nav-anchor" id="Input-type-2" href="#Input-type-2">Input type</a></h3><p>No extension necessary</p><h3><a class="nav-anchor" id="Probability-distribution-family-2" href="#Probability-distribution-family-2">Probability distribution family</a></h3><p>A family of probability distributions <span>$p(t, r; x)$</span> that is normalized for all <span>$x \in X$</span>, that factors according to:</p><div>\[p(t, r; x) = p(t; x) p(r; t, x)\]</div><h3><a class="nav-anchor" id="Return-value-function-2" href="#Return-value-function-2">Return value function</a></h3><p>The return value <em>cannot</em> be a function of the non-addressable randomness. It remains a function <span>$f$</span> on tuples <span>$(x, t)$</span>.</p><h3><a class="nav-anchor" id="Internal-proposal-distribution-family-2" href="#Internal-proposal-distribution-family-2">Internal proposal distribution family</a></h3><p>A family of distributions <span>$q(t, r; x, u)$</span> that factors according to:</p><div>\[q(t, r; x, u) = q(t; x, u) q(r; x, t)\]</div><p>where <span>$q(t; x, u)$</span> satisfies the conditions stated above. Note that the distribution on internal randomness does not depend on <span>$u$</span> in this factorization.</p><h3><a class="nav-anchor" id="Generative-Function-Interface-1" href="#Generative-Function-Interface-1">Generative Function Interface</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.has_argument_grads" href="#Gen.has_argument_grads"><code>Gen.has_argument_grads</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bools::Tuple = has_argument_grads(gen_fn::Union{GenerativeFunction,Distribution})</code></pre><p>Return a tuple of booleans indicating whether a gradient is available for each of its arguments.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/fca26a87f35b7d66b28bd6240d1fe96e38ca2fc0/src/gen_fn_interface.jl#L66-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.accepts_output_grad" href="#Gen.accepts_output_grad"><code>Gen.accepts_output_grad</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">req::Bool = accepts_output_grad(gen_fn::GenerativeFunction)</code></pre><p>Return a boolean indicating whether the return value is dependent on any of the <em>gradient source elements</em> for any trace.</p><p>The gradient source elements are:</p><ul><li><p>Any argument whose position is true in <code>has_argument_grads</code></p></li><li><p>Any static parameter</p></li><li><p>Random choices made at a set of addresses that are selectable by <code>backprop_trace</code>.</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/fca26a87f35b7d66b28bd6240d1fe96e38ca2fc0/src/gen_fn_interface.jl#L73-L85">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.initialize" href="#Gen.initialize"><code>Gen.initialize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(trace::U, weight) = initialize(gen_fn::GenerativeFunction{T,U}, args::Tuple,
                                assmt::Assignment)</code></pre><p>Return a trace of a generative function that is consistent with the given assignment.</p><p><strong>Basic case</strong></p><p>Given arguments <span>$x$</span> (<code>args</code>) and assignment <span>$u$</span> (<code>assmt</code>), sample <span>$t \sim Q(\cdot; u, x)$</span> and return the trace <span>$(x, t)$</span> (<code>trace</code>).  Also return the weight (<code>weight</code>):</p><div>\[\frac{P(t; x)}{Q(t; u, x)}\]</div><p><strong>General case</strong></p><p>Identical to the basic case, except that we also sample <span>$r \sim Q(\cdot; x, t)$</span>, the trace is <span>$(x, t, r)$</span> and the weight is:</p><div>\[\frac{P(t; x)}{Q(t; u, x)}
\cdot \frac{P(r; x, t)}{Q(r; x, t)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/fca26a87f35b7d66b28bd6240d1fe96e38ca2fc0/src/gen_fn_interface.jl#L95-L119">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.project" href="#Gen.project"><code>Gen.project</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">weight = project(trace::U, selection::AddressSet)</code></pre><p>Estimate the probability that the selected choices take the values they do in a trace. </p><p><strong>Basic case</strong></p><p>Given a trace <span>$(x, t)$</span> (<code>trace</code>) and a set of addresses <span>$A$</span> (<code>selection</code>), let <span>$u$</span> denote the restriction of <span>$t$</span> to <span>$A$</span>. Return the weight (<code>weight</code>):</p><div>\[\frac{P(t; x)}{Q(t; u, x)}\]</div><p><strong>General case</strong></p><p>Identical to the basic case except that the previous trace is <span>$(x, t, r)$</span> and the weight is:</p><div>\[\frac{P(t; x)}{Q(t; u, x)}
\cdot \frac{P(r; x, t)}{Q(r; x, t)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/fca26a87f35b7d66b28bd6240d1fe96e38ca2fc0/src/gen_fn_interface.jl#L129-L152">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.propose" href="#Gen.propose"><code>Gen.propose</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(assmt, weight, retval) = propose(gen_fn::GenerativeFunction, args::Tuple)</code></pre><p>Sample an assignment and compute the probability of proposing that assignment.</p><p><strong>Basic case</strong></p><p>Given arguments (<code>args</code>), sample <span>$t&#39; \sim P(\cdot; x)$</span>, and return <span>$t$</span> (<code>assmt</code>) and the weight (<code>weight</code>) <span>$P(t; x)$</span>.</p><p><strong>General case</strong></p><p>Identical to the basic case, except that we also sample <span>$r \sim P(\cdot; x, t)$</span>, and the weight is:</p><div>\[P(t; x)
\cdot \frac{P(r; x, t)}{Q(r; x, t)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/fca26a87f35b7d66b28bd6240d1fe96e38ca2fc0/src/gen_fn_interface.jl#L157-L175">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.assess" href="#Gen.assess"><code>Gen.assess</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(weight, retval) = assess(gen_fn::GenerativeFunction, args::Tuple, assmt::Assignment)</code></pre><p>Return the probability of proposing an assignment</p><p><strong>Basic case</strong></p><p>Given arguments <span>$x$</span> (<code>args</code>) and an assignment <span>$t$</span> (<code>assmt</code>) such that <span>$P(t; x) &gt; 0$</span>, return the weight (<code>weight</code>) <span>$P(t; x)$</span>.  It is an error if <span>$P(t; x) = 0$</span>.</p><p><strong>General case</strong></p><p>Identical to the basic case except that we also sample <span>$r \sim Q(\cdot; x, t)$</span>, and the weight is:</p><div>\[P(t; x)
\cdot \frac{P(r; x, t)}{Q(r; x, t)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/fca26a87f35b7d66b28bd6240d1fe96e38ca2fc0/src/gen_fn_interface.jl#L180-L199">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.force_update" href="#Gen.force_update"><code>Gen.force_update</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, weight, discard, retdiff) = force_update(args::Tuple, argdiff, trace,
                                                     assmt::Assignment)</code></pre><p>Update a trace by changing the arguments and/or providing new values for some existing random choice(s) and values for any newly introduced random choice(s).</p><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>), new arguments <span>$x&#39;$</span> (<code>args</code>), and an assignment <span>$u$</span> (<code>assmt</code>), return a new trace <span>$(x&#39;, t&#39;)$</span> (<code>new_trace</code>) that is consistent with <span>$u$</span>.  The values of choices in <span>$t&#39;$</span> are deterministically copied either from <span>$t$</span> or from <span>$u$</span> (with <span>$u$</span> taking precedence).  All choices in <span>$u$</span> must appear in <span>$t&#39;$</span>.  Also return an assignment <span>$v$</span> (<code>discard</code>) containing the choices in <span>$t$</span> that were overwritten by values from <span>$u$</span>, and any choices in <span>$t$</span> whose address does not appear in <span>$t&#39;$</span>.  Also return the weight (<code>weight</code>):</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)}\]</div><p><strong>General case</strong></p><p>Identical to the basic case except that the previous trace is <span>$(x, t, r)$</span>, the new trace is <span>$(x&#39;, t&#39;, r&#39;)$</span> where <span>$r&#39; \sim Q(\cdot; x&#39;, t&#39;)$</span>, and the weight is:</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)}
\cdot \frac{P(r&#39;; x&#39;, t&#39;) Q(r; x, t)}{P(r; x, t) Q(r&#39;; x&#39;, t&#39;)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/fca26a87f35b7d66b28bd6240d1fe96e38ca2fc0/src/gen_fn_interface.jl#L205-L235">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.fix_update" href="#Gen.fix_update"><code>Gen.fix_update</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, weight, discard, retdiff) = fix_update(args::Tuple, argdiff, trace,
                                                   assmt::Assignment)</code></pre><p>Update a trace, by changing the arguments and/or providing new values for some existing random choice(s).</p><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>), new arguments <span>$x&#39;$</span> (<code>args</code>), and an assignment <span>$u$</span> (<code>assmt</code>), return a new trace <span>$(x&#39;, t&#39;)$</span> (<code>new_trace</code>) that is consistent with <span>$u$</span>.  Let <span>$u + t$</span> denote the merge of <span>$u$</span> and <span>$t$</span> (with <span>$u$</span> taking precedence).  Sample <span>$t&#39; \sim Q(\cdot; u + t, x)$</span>. All addresses in <span>$u$</span> must appear in <span>$t$</span> and in <span>$t&#39;$</span>.  Also return an assignment <span>$v$</span> (<code>discard</code>) containing the values from <span>$t$</span> for addresses in <span>$u$</span>.  Also return the weight (<code>weight</code>):</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)} \cdot \frac{Q(t; v + t&#39;, x)}{Q(t&#39;; u + t, x&#39;)}\]</div><p><strong>General case</strong></p><p>Identical to the basic case except that the previous trace is <span>$(x, t, r)$</span>, the new trace is <span>$(x&#39;, t&#39;, r&#39;)$</span> where <span>$r&#39; \sim Q(\cdot; x&#39;, t&#39;)$</span>, and the weight is:</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)}
\cdot \frac{Q(t; v + t&#39;, x)}{Q(t&#39;; u + t, x&#39;)}
\cdot \frac{P(r&#39;; x&#39;, t&#39;) Q(r; x, t)}{P(r; x, t) Q(r&#39;; x&#39;, t&#39;)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/fca26a87f35b7d66b28bd6240d1fe96e38ca2fc0/src/gen_fn_interface.jl#L240-L270">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.free_update" href="#Gen.free_update"><code>Gen.free_update</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, weight, retdiff) = free_update(args::Tuple, argdiff, trace,
                                           selection::AddressSet)</code></pre><p>Update a trace by changing the arguments and/or randomly sampling new values for selected random choices.</p><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>), new arguments <span>$x&#39;$</span> (<code>args</code>), and a set of addresses <span>$A$</span> (<code>selection</code>), return a new trace <span>$(x&#39;, t&#39;)$</span> (<code>new_trace</code>) such that <span>$t&#39;$</span> agrees with <span>$t$</span> on all addresses not in <span>$A$</span> (<span>$t$</span> and <span>$t&#39;$</span> may have different sets of addresses).  Let <span>$u$</span> denote the restriction of <span>$t$</span> to the complement of <span>$A$</span>.  Sample <span>$t&#39; \sim Q(\cdot; u, x&#39;)$</span>.  Return the new trace <span>$(x&#39;, t&#39;)$</span> (<code>new_trace</code>) and the weight (<code>weight</code>):</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)}
\cdot \frac{Q(t; u&#39;, x)}{Q(t&#39;; u, x&#39;)}\]</div><p>where <span>$u&#39;$</span> is the restriction of <span>$t&#39;$</span> to the complement of <span>$A$</span>.</p><p><strong>General case</strong></p><p>Identical to the basic case except that the previous trace is <span>$(x, t, r)$</span>, the new trace is <span>$(x&#39;, t&#39;, r&#39;)$</span> where <span>$r&#39; \sim Q(\cdot; x&#39;, t&#39;)$</span>, and the weight is:</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)}
\cdot \frac{Q(t; u&#39;, x)}{Q(t&#39;; u, x&#39;)}
\cdot \frac{P(r&#39;; x&#39;, t&#39;) Q(r; x, t)}{P(r; x, t) Q(r&#39;; x&#39;, t&#39;)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/fca26a87f35b7d66b28bd6240d1fe96e38ca2fc0/src/gen_fn_interface.jl#L275-L307">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.extend" href="#Gen.extend"><code>Gen.extend</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, weight, retdiff) = extend(args::Tuple, argdiff, trace, assmt::Assignment)</code></pre><p>Extend a trace with new random choices by changing the arguments.</p><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>), new arguments <span>$x&#39;$</span> (<code>args</code>), and an assignment <span>$u$</span> (<code>assmt</code>) that shares no addresses with <span>$t$</span>, return a new trace <span>$(x&#39;, t&#39;)$</span> (<code>new_trace</code>) such that <span>$t&#39;$</span> agrees with <span>$t$</span> on all addresses in <span>$t$</span> and <span>$t&#39;$</span> agrees with <span>$u$</span> on all addresses in <span>$u$</span>. Sample <span>$t&#39; \sim Q(\cdot; t + u, x&#39;)$</span>. Also return the weight (<code>weight</code>):</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x) Q(t&#39;; t + u, x&#39;)}\]</div><p><strong>General case</strong></p><p>Identical to the basic case except that the previous trace is <span>$(x, t, r)$</span>, and we also sample <span>$r&#39; \sim Q(\cdot; t&#39;, x)$</span>, the new trace is <span>$(x&#39;, t&#39;, r&#39;)$</span>, and the weight is:</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x) Q(t&#39;; t + u, x&#39;)}
\cdot \frac{P(r&#39;; x&#39;, t&#39;) Q(r; x, t)}{P(r; x, t) Q(r&#39;; x&#39;, t&#39;)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/fca26a87f35b7d66b28bd6240d1fe96e38ca2fc0/src/gen_fn_interface.jl#L312-L337">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.backprop_params" href="#Gen.backprop_params"><code>Gen.backprop_params</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">arg_grads = backprop_params(trace, retgrad, scaler=1.)</code></pre><p>Increment gradient accumulators for parameters by the gradient of the log-probability of the trace, optionally scaled, and return the gradient with respect to the arguments (not scaled).</p><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>) and a gradient with respect to the return value <span>$∇_y J$</span> (<code>retgrad</code>), return the following gradient (<code>arg_grads</code>) with respect to the arguments <span>$x$</span>:</p><div>\[∇_x \left( \log P(t; x) + J \right)\]</div><p>Also increment the gradient accumulators for the static parameters <span>$Θ$</span> of the function by:</p><div>\[∇_Θ \left( \log P(t; x) + J \right)\]</div><p><strong>General case</strong></p><p>Not yet formalized.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/fca26a87f35b7d66b28bd6240d1fe96e38ca2fc0/src/gen_fn_interface.jl#L342-L366">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.backprop_trace" href="#Gen.backprop_trace"><code>Gen.backprop_trace</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(arg_grads, choice_values, choice_grads) = backprop_trace(trace, selection::AddressSet,
                                                          retgrad)</code></pre><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>) and a gradient with respect to the return value <span>$∇_y J$</span> (<code>retgrad</code>), return the following gradient (<code>arg_grads</code>) with respect to the arguments <span>$x$</span>:</p><div>\[∇_x \left( \log P(t; x) + J \right)\]</div><p>Also given a set of addresses <span>$A$</span> (<code>selection</code>) that are continuous-valued random choices, return the folowing gradient (<code>choice_grads</code>) with respect to the values of these choices:</p><div>\[∇_A \left( \log P(t; x) + J \right)\]</div><p>Also return the assignment (<code>choice_values</code>) that is the restriction of <span>$t$</span> to <span>$A$</span>.</p><p><strong>General case</strong></p><p>Not yet formalized.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/fca26a87f35b7d66b28bd6240d1fe96e38ca2fc0/src/gen_fn_interface.jl#L373-L396">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_assmt" href="#Gen.get_assmt"><code>Gen.get_assmt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_assmt(trace)</code></pre><p>Return a value implementing the assignment interface</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/fca26a87f35b7d66b28bd6240d1fe96e38ca2fc0/src/gen_fn_interface.jl#L19-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_args" href="#Gen.get_args"><code>Gen.get_args</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_args(trace)</code></pre><p>Return the argument tuple for a given execution.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/fca26a87f35b7d66b28bd6240d1fe96e38ca2fc0/src/gen_fn_interface.jl#L5-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_retval" href="#Gen.get_retval"><code>Gen.get_retval</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_retval(trace)</code></pre><p>Return the return value of the given execution.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/fca26a87f35b7d66b28bd6240d1fe96e38ca2fc0/src/gen_fn_interface.jl#L12-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_score" href="#Gen.get_score"><code>Gen.get_score</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_score(trace)</code></pre><p><strong>Basic case</strong></p><p>Return <span>$P(t; x)$</span></p><p><strong>General case</strong></p><p>Return <span>$P(r, t; x) / Q(r; tx, t)$</span></p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/fca26a87f35b7d66b28bd6240d1fe96e38ca2fc0/src/gen_fn_interface.jl#L26-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_gen_fn" href="#Gen.get_gen_fn"><code>Gen.get_gen_fn</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gen_fn::GenerativeFunction = get_gen_fn(trace)</code></pre><p>Return the generative function that produced the given trace.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/fca26a87f35b7d66b28bd6240d1fe96e38ca2fc0/src/gen_fn_interface.jl#L39-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_params" href="#Gen.get_params"><code>Gen.get_params</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_params(gen_fn::GenerativeFunction)</code></pre><p>Return an iterable over the trainable parameters of the generative function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/fca26a87f35b7d66b28bd6240d1fe96e38ca2fc0/src/gen_fn_interface.jl#L88-L92">source</a></section><footer><hr/><a class="previous" href="../../tutorials/"><span class="direction">Previous</span><span class="title">Tutorials</span></a><a class="next" href="../distributions/"><span class="direction">Next</span><span class="title">Probability Distributions</span></a></footer></article></body></html>
