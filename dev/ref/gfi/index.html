<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Generative Function Interface · Gen</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Gen</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../getting_started/">Getting Started</a></li><li><a class="toctext" href="../../tutorials/">Tutorials</a></li><li><a class="toctext" href="../../guide/">Guide</a></li><li><span class="toctext">Language and API Reference</span><ul><li><a class="toctext" href="../modeling/">Built-in Modeling Language</a></li><li><a class="toctext" href="../combinators/">Generative Function Combinators</a></li><li><a class="toctext" href="../assignments/">Assignments</a></li><li><a class="toctext" href="../selections/">Selections</a></li><li><a class="toctext" href="../parameter_optimization/">Optimizing Trainable Parameters</a></li><li><a class="toctext" href="../inference/">Inference Library</a></li><li class="current"><a class="toctext" href>Generative Function Interface</a><ul class="internal"></ul></li><li><a class="toctext" href="../distributions/">Probability Distributions</a></li></ul></li><li><span class="toctext">Internals</span><ul><li><a class="toctext" href="../internals/parameter_optimization/">Optimizing Trainable Parameters</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Language and API Reference</li><li><a href>Generative Function Interface</a></li></ul><a class="edit-page" href="https://github.com/probcomp/Gen/blob/master/docs/src/ref/gfi.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Generative Function Interface</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Generative-Function-Interface-1" href="#Generative-Function-Interface-1">Generative Function Interface</a></h1><p>A <em>trace</em> is a record of an execution of a generative function. There is no abstract type representing all traces. Generative functions implement the <em>generative function interface</em>, which is a set of methods that involve the execution traces and probabilistic behavior of generative functions. In the mathematical description of the interface methods, we denote arguments to a function by <span>$x$</span>, complete assignments of values to addresses of random choices (containing all the random choices made during some execution) by <span>$t$</span> and partial assignments by either <span>$u$</span> or <span>$v$</span>. We denote a trace of a generative function by the tuple <span>$(x, t)$</span>. We say that two assignments <span>$u$</span> and <span>$t$</span> <em>agree</em> when they assign addresses that appear in both assignments to the same values (they can different or even disjoint sets of addresses and still agree). A generative function is associated with a family of probability distributions <span>$P(t; x)$</span> on assignments <span>$t$</span>, parameterized by arguments <span>$x$</span>, and a second family of distributions <span>$Q(t; u, x)$</span> on assignments <span>$t$</span> parameterized by partial assignment <span>$u$</span> and arguments <span>$x$</span>. <span>$Q$</span> is called the <em>internal proposal family</em> of the generative function, and satisfies that if <span>$u$</span> and <span>$t$</span> agree then <span>$P(t; x) &gt; 0$</span> if and only if <span>$Q(t; x, u) &gt; 0$</span>, and that <span>$Q(t; x, u) &gt; 0$</span> implies that <span>$u$</span> and <span>$t$</span> agree. See the <a href="http://hdl.handle.net/1721.1/119255">Gen technical report</a> for additional details.</p><h3><a class="nav-anchor" id="Non-addressabe-random-choices-1" href="#Non-addressabe-random-choices-1">Non-addressabe random choices</a></h3><p>Generative functions may also use <em>non-addressable random choices</em>, denoted <span>$r$</span>. Unlike regular (addressable) random choices, non-addressable random choices do not have addresses, and the value of non-addressable random choices is not exposed through the generative function interface. However, the state of non-addressable random choices is maintained in the trace. A trace that contains non-addressable random choices is denoted <span>$(x, t, r)$</span>. Non-addressable random choices manifest to the user of the interface as stochasticity in weights returned by generative function interface methods. The behavior of non-addressable random choices is defined by an additional pair of families of distributions associated with the generative function, denoted <span>$Q(r; x, t)$</span> and <span>$P(r; x, t)$</span>, which are defined for <span>$P(t; x) &gt; 0$</span>, and which satisfy <span>$Q(r; x, t) &gt; 0$</span> if and only if <span>$P(r; x, t) &gt; 0$</span>. For each generative function below, we describe its semantics first in the basic setting where there is no non-addressable random choices, and then in the more general setting that may include non-addressable random choices.</p><h3><a class="nav-anchor" id="Differentiable-programming-1" href="#Differentiable-programming-1">Differentiable programming</a></h3><p>Generative functions may support computation of gradients with respect to (i) all or a subset of its arguments, (ii) its <strong>trainable parameters</strong>, and (iii) the value of certain random choices. The set of elements (either arguments, trainable parameters, or random choices) for which gradients are available is called the <em>gradient source set</em>. A generative function statically reports whether or not it is able to compute gradients with respect to each of its arguments, through the function <code>has_argument_grads</code>. Let <span>$x_G$</span> denote the set of arguments for which the generative function does support gradient computation. Similarly, a generative function supports gradients with respect the value of random choices made at all or a subset of addresses. If the return value of the function is conditionally independent of each element in the gradient source set given the other elements in the gradient source set and values of all other random choices, for all possible traces of the function, then the generative function requires a <em>return value gradient</em> to compute gradients with respect to elements of the gradient source set. This static property of the generative function is reported by <code>accepts_output_grad</code>.</p><h3><a class="nav-anchor" id="Trainable-parameters-1" href="#Trainable-parameters-1">Trainable parameters</a></h3><h3><a class="nav-anchor" id="Interface-methods-1" href="#Interface-methods-1">Interface methods</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.has_argument_grads" href="#Gen.has_argument_grads"><code>Gen.has_argument_grads</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bools::Tuple = has_argument_grads(gen_fn::Union{GenerativeFunction,Distribution})</code></pre><p>Return a tuple of booleans indicating whether a gradient is available for each of its arguments.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/c97262bedb31777fe88b858f7a0c1f4aa7e10f17/src/gen_fn_interface.jl#L64-L68">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.accepts_output_grad" href="#Gen.accepts_output_grad"><code>Gen.accepts_output_grad</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">req::Bool = accepts_output_grad(gen_fn::GenerativeFunction)</code></pre><p>Return a boolean indicating whether the return value is dependent on any of the <em>gradient source elements</em> for any trace.</p><p>The gradient source elements are:</p><ul><li><p>Any argument whose position is true in <code>has_argument_grads</code></p></li><li><p>Any static parameter</p></li><li><p>Random choices made at a set of addresses that are selectable by <code>backprop_trace</code>.</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/c97262bedb31777fe88b858f7a0c1f4aa7e10f17/src/gen_fn_interface.jl#L71-L83">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.initialize" href="#Gen.initialize"><code>Gen.initialize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(trace::U, weight) = initialize(gen_fn::GenerativeFunction{T,U}, args::Tuple,
                                assmt::Assignment)</code></pre><p>Return a trace of a generative function that is consistent with the given assignment.</p><p><strong>Basic case</strong></p><p>Given arguments <span>$x$</span> (<code>args</code>) and assignment <span>$u$</span> (<code>assmt</code>), sample <span>$t \sim Q(\cdot; u, x)$</span> and return the trace <span>$(x, t)$</span> (<code>trace</code>).  Also return the weight (<code>weight</code>):</p><div>\[\frac{P(t; x)}{Q(t; u, x)}\]</div><p><strong>General case</strong></p><p>Identical to the basic case, except that we also sample <span>$r \sim Q(\cdot; x, t)$</span>, the trace is <span>$(x, t, r)$</span> and the weight is:</p><div>\[\frac{P(t; x)}{Q(t; u, x)}
\cdot \frac{P(r; x, t)}{Q(r; x, t)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/c97262bedb31777fe88b858f7a0c1f4aa7e10f17/src/gen_fn_interface.jl#L93-L117">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.project" href="#Gen.project"><code>Gen.project</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">weight = project(trace::U, selection::AddressSet)</code></pre><p>Estimate the probability that the selected choices take the values they do in a trace. </p><p><strong>Basic case</strong></p><p>Given a trace <span>$(x, t)$</span> (<code>trace</code>) and a set of addresses <span>$A$</span> (<code>selection</code>), let <span>$u$</span> denote the restriction of <span>$t$</span> to <span>$A$</span>. Return the weight (<code>weight</code>):</p><div>\[\frac{P(t; x)}{Q(t; u, x)}\]</div><p><strong>General case</strong></p><p>Identical to the basic case except that the previous trace is <span>$(x, t, r)$</span> and the weight is:</p><div>\[\frac{P(t; x)}{Q(t; u, x)}
\cdot \frac{P(r; x, t)}{Q(r; x, t)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/c97262bedb31777fe88b858f7a0c1f4aa7e10f17/src/gen_fn_interface.jl#L127-L150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.propose" href="#Gen.propose"><code>Gen.propose</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(assmt, weight, retval) = propose(gen_fn::GenerativeFunction, args::Tuple)</code></pre><p>Sample an assignment and compute the probability of proposing that assignment.</p><p><strong>Basic case</strong></p><p>Given arguments (<code>args</code>), sample <span>$t&#39; \sim P(\cdot; x)$</span>, and return <span>$t$</span> (<code>assmt</code>) and the weight (<code>weight</code>) <span>$P(t; x)$</span>.</p><p><strong>General case</strong></p><p>Identical to the basic case, except that we also sample <span>$r \sim P(\cdot; x, t)$</span>, and the weight is:</p><div>\[P(t; x)
\cdot \frac{P(r; x, t)}{Q(r; x, t)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/c97262bedb31777fe88b858f7a0c1f4aa7e10f17/src/gen_fn_interface.jl#L155-L173">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.assess" href="#Gen.assess"><code>Gen.assess</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(weight, retval) = assess(gen_fn::GenerativeFunction, args::Tuple, assmt::Assignment)</code></pre><p>Return the probability of proposing an assignment</p><p><strong>Basic case</strong></p><p>Given arguments <span>$x$</span> (<code>args</code>) and an assignment <span>$t$</span> (<code>assmt</code>) such that <span>$P(t; x) &gt; 0$</span>, return the weight (<code>weight</code>) <span>$P(t; x)$</span>.  It is an error if <span>$P(t; x) = 0$</span>.</p><p><strong>General case</strong></p><p>Identical to the basic case except that we also sample <span>$r \sim Q(\cdot; x, t)$</span>, and the weight is:</p><div>\[P(t; x)
\cdot \frac{P(r; x, t)}{Q(r; x, t)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/c97262bedb31777fe88b858f7a0c1f4aa7e10f17/src/gen_fn_interface.jl#L178-L197">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.force_update" href="#Gen.force_update"><code>Gen.force_update</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, weight, discard, retdiff) = force_update(args::Tuple, argdiff, trace,
                                                     assmt::Assignment)</code></pre><p>Update a trace by changing the arguments and/or providing new values for some existing random choice(s) and values for any newly introduced random choice(s).</p><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>), new arguments <span>$x&#39;$</span> (<code>args</code>), and an assignment <span>$u$</span> (<code>assmt</code>), return a new trace <span>$(x&#39;, t&#39;)$</span> (<code>new_trace</code>) that is consistent with <span>$u$</span>.  The values of choices in <span>$t&#39;$</span> are deterministically copied either from <span>$t$</span> or from <span>$u$</span> (with <span>$u$</span> taking precedence).  All choices in <span>$u$</span> must appear in <span>$t&#39;$</span>.  Also return an assignment <span>$v$</span> (<code>discard</code>) containing the choices in <span>$t$</span> that were overwritten by values from <span>$u$</span>, and any choices in <span>$t$</span> whose address does not appear in <span>$t&#39;$</span>.  Also return the weight (<code>weight</code>):</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)}\]</div><p><strong>General case</strong></p><p>Identical to the basic case except that the previous trace is <span>$(x, t, r)$</span>, the new trace is <span>$(x&#39;, t&#39;, r&#39;)$</span> where <span>$r&#39; \sim Q(\cdot; x&#39;, t&#39;)$</span>, and the weight is:</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)}
\cdot \frac{P(r&#39;; x&#39;, t&#39;) Q(r; x, t)}{P(r; x, t) Q(r&#39;; x&#39;, t&#39;)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/c97262bedb31777fe88b858f7a0c1f4aa7e10f17/src/gen_fn_interface.jl#L203-L233">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.fix_update" href="#Gen.fix_update"><code>Gen.fix_update</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, weight, discard, retdiff) = fix_update(args::Tuple, argdiff, trace,
                                                   assmt::Assignment)</code></pre><p>Update a trace, by changing the arguments and/or providing new values for some existing random choice(s).</p><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>), new arguments <span>$x&#39;$</span> (<code>args</code>), and an assignment <span>$u$</span> (<code>assmt</code>), return a new trace <span>$(x&#39;, t&#39;)$</span> (<code>new_trace</code>) that is consistent with <span>$u$</span>.  Let <span>$u + t$</span> denote the merge of <span>$u$</span> and <span>$t$</span> (with <span>$u$</span> taking precedence).  Sample <span>$t&#39; \sim Q(\cdot; u + t, x)$</span>. All addresses in <span>$u$</span> must appear in <span>$t$</span> and in <span>$t&#39;$</span>.  Also return an assignment <span>$v$</span> (<code>discard</code>) containing the values from <span>$t$</span> for addresses in <span>$u$</span>.  Also return the weight (<code>weight</code>):</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)} \cdot \frac{Q(t; v + t&#39;, x)}{Q(t&#39;; u + t, x&#39;)}\]</div><p><strong>General case</strong></p><p>Identical to the basic case except that the previous trace is <span>$(x, t, r)$</span>, the new trace is <span>$(x&#39;, t&#39;, r&#39;)$</span> where <span>$r&#39; \sim Q(\cdot; x&#39;, t&#39;)$</span>, and the weight is:</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)}
\cdot \frac{Q(t; v + t&#39;, x)}{Q(t&#39;; u + t, x&#39;)}
\cdot \frac{P(r&#39;; x&#39;, t&#39;) Q(r; x, t)}{P(r; x, t) Q(r&#39;; x&#39;, t&#39;)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/c97262bedb31777fe88b858f7a0c1f4aa7e10f17/src/gen_fn_interface.jl#L238-L268">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.free_update" href="#Gen.free_update"><code>Gen.free_update</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, weight, retdiff) = free_update(args::Tuple, argdiff, trace,
                                           selection::AddressSet)</code></pre><p>Update a trace by changing the arguments and/or randomly sampling new values for selected random choices.</p><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>), new arguments <span>$x&#39;$</span> (<code>args</code>), and a set of addresses <span>$A$</span> (<code>selection</code>), return a new trace <span>$(x&#39;, t&#39;)$</span> (<code>new_trace</code>) such that <span>$t&#39;$</span> agrees with <span>$t$</span> on all addresses not in <span>$A$</span> (<span>$t$</span> and <span>$t&#39;$</span> may have different sets of addresses).  Let <span>$u$</span> denote the restriction of <span>$t$</span> to the complement of <span>$A$</span>.  Sample <span>$t&#39; \sim Q(\cdot; u, x&#39;)$</span>.  Return the new trace <span>$(x&#39;, t&#39;)$</span> (<code>new_trace</code>) and the weight (<code>weight</code>):</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)}
\cdot \frac{Q(t; u&#39;, x)}{Q(t&#39;; u, x&#39;)}\]</div><p>where <span>$u&#39;$</span> is the restriction of <span>$t&#39;$</span> to the complement of <span>$A$</span>.</p><p><strong>General case</strong></p><p>Identical to the basic case except that the previous trace is <span>$(x, t, r)$</span>, the new trace is <span>$(x&#39;, t&#39;, r&#39;)$</span> where <span>$r&#39; \sim Q(\cdot; x&#39;, t&#39;)$</span>, and the weight is:</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)}
\cdot \frac{Q(t; u&#39;, x)}{Q(t&#39;; u, x&#39;)}
\cdot \frac{P(r&#39;; x&#39;, t&#39;) Q(r; x, t)}{P(r; x, t) Q(r&#39;; x&#39;, t&#39;)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/c97262bedb31777fe88b858f7a0c1f4aa7e10f17/src/gen_fn_interface.jl#L273-L305">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.extend" href="#Gen.extend"><code>Gen.extend</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, weight, retdiff) = extend(args::Tuple, argdiff, trace, assmt::Assignment)</code></pre><p>Extend a trace with new random choices by changing the arguments.</p><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>), new arguments <span>$x&#39;$</span> (<code>args</code>), and an assignment <span>$u$</span> (<code>assmt</code>) that shares no addresses with <span>$t$</span>, return a new trace <span>$(x&#39;, t&#39;)$</span> (<code>new_trace</code>) such that <span>$t&#39;$</span> agrees with <span>$t$</span> on all addresses in <span>$t$</span> and <span>$t&#39;$</span> agrees with <span>$u$</span> on all addresses in <span>$u$</span>. Sample <span>$t&#39; \sim Q(\cdot; t + u, x&#39;)$</span>. Also return the weight (<code>weight</code>):</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x) Q(t&#39;; t + u, x&#39;)}\]</div><p><strong>General case</strong></p><p>Identical to the basic case except that the previous trace is <span>$(x, t, r)$</span>, and we also sample <span>$r&#39; \sim Q(\cdot; t&#39;, x)$</span>, the new trace is <span>$(x&#39;, t&#39;, r&#39;)$</span>, and the weight is:</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x) Q(t&#39;; t + u, x&#39;)}
\cdot \frac{P(r&#39;; x&#39;, t&#39;) Q(r; x, t)}{P(r; x, t) Q(r&#39;; x&#39;, t&#39;)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/c97262bedb31777fe88b858f7a0c1f4aa7e10f17/src/gen_fn_interface.jl#L310-L335">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.backprop_params" href="#Gen.backprop_params"><code>Gen.backprop_params</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">arg_grads = backprop_params(trace, retgrad, scaler=1.)</code></pre><p>Increment gradient accumulators for parameters by the gradient of the log-probability of the trace, optionally scaled, and return the gradient with respect to the arguments (not scaled).</p><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>) and a gradient with respect to the return value <span>$∇_y J$</span> (<code>retgrad</code>), return the following gradient (<code>arg_grads</code>) with respect to the arguments <span>$x$</span>:</p><div>\[∇_x \left( \log P(t; x) + J \right)\]</div><p>Also increment the gradient accumulators for the static parameters <span>$Θ$</span> of the function by:</p><div>\[∇_Θ \left( \log P(t; x) + J \right)\]</div><p><strong>General case</strong></p><p>Not yet formalized.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/c97262bedb31777fe88b858f7a0c1f4aa7e10f17/src/gen_fn_interface.jl#L340-L364">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.backprop_trace" href="#Gen.backprop_trace"><code>Gen.backprop_trace</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(arg_grads, choice_values, choice_grads) = backprop_trace(trace, selection::AddressSet,
                                                          retgrad)</code></pre><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>) and a gradient with respect to the return value <span>$∇_y J$</span> (<code>retgrad</code>), return the following gradient (<code>arg_grads</code>) with respect to the arguments <span>$x$</span>:</p><div>\[∇_x \left( \log P(t; x) + J \right)\]</div><p>Also given a set of addresses <span>$A$</span> (<code>selection</code>) that are continuous-valued random choices, return the folowing gradient (<code>choice_grads</code>) with respect to the values of these choices:</p><div>\[∇_A \left( \log P(t; x) + J \right)\]</div><p>Also return the assignment (<code>choice_values</code>) that is the restriction of <span>$t$</span> to <span>$A$</span>.</p><p><strong>General case</strong></p><p>Not yet formalized.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/c97262bedb31777fe88b858f7a0c1f4aa7e10f17/src/gen_fn_interface.jl#L371-L394">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_assmt" href="#Gen.get_assmt"><code>Gen.get_assmt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_assmt(trace)</code></pre><p>Return a value implementing the assignment interface</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/c97262bedb31777fe88b858f7a0c1f4aa7e10f17/src/gen_fn_interface.jl#L19-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_args" href="#Gen.get_args"><code>Gen.get_args</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_args(trace)</code></pre><p>Return the argument tuple for a given execution.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/c97262bedb31777fe88b858f7a0c1f4aa7e10f17/src/gen_fn_interface.jl#L5-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_retval" href="#Gen.get_retval"><code>Gen.get_retval</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_retval(trace)</code></pre><p>Return the return value of the given execution.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/c97262bedb31777fe88b858f7a0c1f4aa7e10f17/src/gen_fn_interface.jl#L12-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_score" href="#Gen.get_score"><code>Gen.get_score</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_score(trace)</code></pre><p><strong>Basic case</strong></p><p>Return <span>$P(t; x)$</span></p><p><strong>General case</strong></p><p>Return <span>$P(r, t; x) / Q(r; tx, t)$</span></p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/c97262bedb31777fe88b858f7a0c1f4aa7e10f17/src/gen_fn_interface.jl#L26-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_gen_fn" href="#Gen.get_gen_fn"><code>Gen.get_gen_fn</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gen_fn::GenerativeFunction = get_gen_fn(trace)</code></pre><p>Return the generative function that produced the given trace.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/c97262bedb31777fe88b858f7a0c1f4aa7e10f17/src/gen_fn_interface.jl#L39-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_params" href="#Gen.get_params"><code>Gen.get_params</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_params(gen_fn::GenerativeFunction)</code></pre><p>Return an iterable over the trainable parameters of the generative function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/c97262bedb31777fe88b858f7a0c1f4aa7e10f17/src/gen_fn_interface.jl#L86-L90">source</a></section><footer><hr/><a class="previous" href="../inference/"><span class="direction">Previous</span><span class="title">Inference Library</span></a><a class="next" href="../distributions/"><span class="direction">Next</span><span class="title">Probability Distributions</span></a></footer></article></body></html>
