<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Gen</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Gen</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../getting_started/">Getting Started</a></li><li><a class="toctext" href="../tutorials/">Tutorials</a></li><li><a class="toctext" href="../guide/">Guide</a></li><li class="current"><a class="toctext" href>Reference</a><ul class="internal"><li><a class="toctext" href="#Modeling-Languages-1">Modeling Languages</a></li><li><a class="toctext" href="#Assignments-1">Assignments</a></li><li><a class="toctext" href="#Selections-1">Selections</a></li><li><a class="toctext" href="#Inference-Library-1">Inference Library</a></li><li><a class="toctext" href="#Generative-Function-Interface-1">Generative Function Interface</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Reference</a></li></ul><a class="edit-page" href="https://github.com/probcomp/Gen/blob/master/docs/src/ref.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Reference-1" href="#Reference-1">Reference</a></h1><h2><a class="nav-anchor" id="Modeling-Languages-1" href="#Modeling-Languages-1">Modeling Languages</a></h2><h3><a class="nav-anchor" id="Addresses-of-Random-Choices-1" href="#Addresses-of-Random-Choices-1">Addresses of Random Choices</a></h3><h3><a class="nav-anchor" id="Dynamic-DSL-1" href="#Dynamic-DSL-1">Dynamic DSL</a></h3><h3><a class="nav-anchor" id="Static-DSL-1" href="#Static-DSL-1">Static DSL</a></h3><h3><a class="nav-anchor" id="Combinators-1" href="#Combinators-1">Combinators</a></h3><h2><a class="nav-anchor" id="Assignments-1" href="#Assignments-1">Assignments</a></h2><p>An <em>assignment</em> is a map from addresses of random choices to their values. Assignments are constructed by users to express observations and/or constraints on the traces of generative functions. Assignments are also returned by certain Gen inference methods, and are used internally by various Gen inference methods.</p><p>There are various concrete types for assignments, each of which is a subtype of <code>Assignment</code>. Assignments provide the following methods:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.has_value" href="#Gen.has_value"><code>Gen.has_value</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">has_value(assmt::Assignment, addr)</code></pre><p>Return true if there is a value at the given address.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/assignment.jl#L41-L45">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_value" href="#Gen.get_value"><code>Gen.get_value</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">value = get_value(assmt::Assignment, addr)</code></pre><p>Return the value at the given address in the assignment, or throw a KeyError if no value exists. A syntactic sugar is <code>Base.getindex</code>:</p><pre><code class="language-none">value = assmt[addr]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/assignment.jl#L23-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_subassmt" href="#Gen.get_subassmt"><code>Gen.get_subassmt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">subassmt = get_subassmt(assmt::Assignment, addr)</code></pre><p>Return the sub-assignment containing all choices whose address is prefixed by addr.</p><p>It is an error if the assignment contains a value at the given address. If there are no choices whose address is prefixed by addr then return an <code>EmptyAssignment</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/assignment.jl#L12-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_values_shallow" href="#Gen.get_values_shallow"><code>Gen.get_values_shallow</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">key_subassmt_iterable = get_values_shallow(assmt::Assignment)</code></pre><p>Return an iterable collection of tuples <code>(key, subassmt::Assignment)</code> for each top-level key associated with a value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/assignment.jl#L48-L53">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_subassmts_shallow" href="#Gen.get_subassmts_shallow"><code>Gen.get_subassmts_shallow</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">key_subassmt_iterable = get_subassmts_shallow(assmt::Assignment)</code></pre><p>Return an iterable collection of tuples <code>(key, subassmt::Assignment)</code> for each top-level key that has a non-empty sub-assignment.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/assignment.jl#L33-L38">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.to_array" href="#Gen.to_array"><code>Gen.to_array</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">arr::Vector{T} = to_array(assmt::Assignment, ::Type{T}) where {T}</code></pre><p>Populate an array with values of choices in the given assignment.</p><p>It is an error if each of the values cannot be coerced into a value of the given type.</p><p><strong>Implementation</strong></p><p>To support <code>to_array</code>, a concrete subtype <code>T &lt;: Assignment</code> should implement the following method:</p><pre><code class="language-none">n::Int = _fill_array!(assmt::T, arr::Vector{V}, start_idx::Int) where {V}</code></pre><p>Populate <code>arr</code> with values from the given assignment, starting at <code>start_idx</code>, and return the number of elements in <code>arr</code> that were populated.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/assignment.jl#L138-L155">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.from_array" href="#Gen.from_array"><code>Gen.from_array</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">assmt::Assignment = from_array(proto_assmt::Assignment, arr::Vector)</code></pre><p>Return an assignment with the same address structure as a prototype assignment, but with values read off from the given array.</p><p>The order in which addresses are populated is determined by the prototype assignment. It is an error if the number of choices in the prototype assignment is not equal to the length the array.</p><p><strong>Implementation</strong></p><p>To support <code>from_array</code>, a concrete subtype <code>T &lt;: Assignment</code> should implement the following method:</p><pre><code class="language-none">(n::Int, assmt::T) = _from_array(proto_assmt::T, arr::Vector{V}, start_idx::Int) where {V}</code></pre><p>Return an assignment with the same address structure as a prototype assignment, but with values read off from <code>arr</code>, starting at position <code>start_idx</code>, and the number of elements read from <code>arr</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/assignment.jl#L164-L185">source</a></section><p>Note that none of these methods mutate the assignment.</p><p>Assignments also provide <code>Base.isempty</code>, which tests of there are no random choices in the assignment, and <code>Base.merge</code>, which takes two assignments, and returns a new assignment containing all random choices in either assignment. It is an error if the assignments both have values at the same address, or if one assignment has a value at an address that is the prefix of the address of a value in the other assignment.</p><h3><a class="nav-anchor" id="Dynamic-Assignment-1" href="#Dynamic-Assignment-1">Dynamic Assignment</a></h3><p>One concrete assignment type is <code>DynamicAssignment</code>, which is mutable. Users construct <code>DynamicAssignments</code> and populate them for use as observations or constraints, e.g.:</p><pre><code class="language-julia">assmt = DynamicAssignment()
assmt[:x] = true
assmt[&quot;foo&quot;] = 1.25
assmt[:y =&gt; 1 =&gt; :z] = -6.3</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.DynamicAssignment" href="#Gen.DynamicAssignment"><code>Gen.DynamicAssignment</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">assmt = DynamicAssignment()</code></pre><p>Construct an empty dynamic assignment.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/assignment.jl#L515-L519">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.set_value!" href="#Gen.set_value!"><code>Gen.set_value!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">set_value!(assmt::DynamicAssignment, addr, value)</code></pre><p>Set the given value for the given address.</p><p>Will cause any previous value or sub-assignment at this address to be deleted. It is an error if there is already a value present at some prefix of the given address.</p><p>The following syntactic sugar is provided:</p><pre><code class="language-none">assmt[addr] = value</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/assignment.jl#L556-L567">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.set_subassmt!" href="#Gen.set_subassmt!"><code>Gen.set_subassmt!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">set_subassmt!(assmt::DynamicAssignment, addr, subassmt::Assignment)</code></pre><p>Replace the sub-assignment rooted at the given address with the given sub-assignment. Set the given value for the given address.</p><p>Will cause any previous value or sub-assignment at the given address to be deleted. It is an error if there is already a value present at some prefix of address.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/assignment.jl#L590-L598">source</a></section><h2><a class="nav-anchor" id="Selections-1" href="#Selections-1">Selections</a></h2><p>A <em>selection</em> is a set of addresses. Users typically construct selections and pass them to Gen inference library methods.</p><p>There are various concrete types for selections, each of which is a subtype of <code>AddressSet</code>. One such concrete type is <code>DynamicAddressSet</code>, which users can populate using <code>Base.push!</code>, e.g.:</p><pre><code class="language-julia">sel = DynamicAddressSet()
push!(sel, :x)
push!(sel, &quot;foo&quot;)
push!(sel, :y =&gt; 1 =&gt; :z)</code></pre><p>There is also the following syntactic sugar:</p><pre><code class="language-julia">sel = select(:x, &quot;foo&quot;, :y =&gt; 1 =&gt; :z)</code></pre><h2><a class="nav-anchor" id="Inference-Library-1" href="#Inference-Library-1">Inference Library</a></h2><h3><a class="nav-anchor" id="Importance-Sampling-1" href="#Importance-Sampling-1">Importance Sampling</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.importance_sampling" href="#Gen.importance_sampling"><code>Gen.importance_sampling</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(traces, log_norm_weights, lml_est) = importance_sampling(model::GenerativeFunction,
    model_args::Tuple, observations::Assignment, num_samples::Int)

(traces, log_norm_weights, lml_est) = importance_sampling(model::GenerativeFunction,
    model_args::Tuple, observations::Assignment,
    proposal::GenerativeFunction, proposal_args::Tuple,
    num_samples::Int)</code></pre><p>Run importance sampling, returning a vector of traces with associated log weights.</p><p>The log-weights are normalized. Also return the estimate of the marginal likelihood of the observations (<code>lml_est</code>). The observations are addresses that must be sampled by the model in the given model arguments. The first variant uses the internal proposal distribution of the model. The second variant uses a custom proposal distribution defined by the given generative function. All addresses of random choices sampled by the proposal should also be sampled by the model function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/inference/importance.jl#L1-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.importance_resampling" href="#Gen.importance_resampling"><code>Gen.importance_resampling</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(trace, lml_est) = importance_resampling(model::GenerativeFunction,
    model_args::Tuple, observations::Assignment, num_samples::Int)

(traces, lml_est) = importance_resampling(model::GenerativeFunction,
    model_args::Tuple, observations::Assignment,
    proposal::GenerativeFunction, proposal_args::Tuple,
    num_samples::Int)</code></pre><p>Run sampling importance resampling, returning a single trace.</p><p>Unlike <code>importance_sampling</code>, the memory used constant in the number of samples.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/inference/importance.jl#L51-L63">source</a></section><h3><a class="nav-anchor" id="Markov-Chain-Monte-Carlo-1" href="#Markov-Chain-Monte-Carlo-1">Markov Chain Monte Carlo</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.default_mh" href="#Gen.default_mh"><code>Gen.default_mh</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, accepted) = default_mh(trace, selection::AddressSet)</code></pre><p>Perform a Metropolis-Hastings update that proposes new values for the selected addresses from the internal proposal (often using ancestral sampling).</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/inference/mh.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.simple_mh" href="#Gen.simple_mh"><code>Gen.simple_mh</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, accepted) = simple_mh(trace, proposal::GenerativeFunction, proposal_args::Tuple)</code></pre><p>Perform a Metropolis-Hastings update that proposes new values for some subset of random choices in the given trace using the given proposal generative function.</p><p>The proposal generative function should take as its first argument the current trace of the model, and remaining arguments <code>proposal_args</code>. All addresses sampled by the proposal must be in the existing model trace. The proposal may modify the control flow of the model, but values of new addresses in the model are sampled from the model&#39;s internal proposal distribution.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/inference/mh.jl#L18-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.custom_mh" href="#Gen.custom_mh"><code>Gen.custom_mh</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, accepted) = custom_mh(trace, proposal::GenerativeFunction, proposal_args::Tuple)</code></pre><p>Perform a Metropolis-Hastings update that proposes new values for some subset of random choices in the given trace using the given proposal generative function.</p><p>The proposal generative function should take as its first argument the current trace of the model, and remaining arguments <code>proposal_args</code>. If the proposal modifies addresses that determine the control flow in the model, values must be provided by the proposal for any addresses that are newly sampled by the model.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/inference/mh.jl#L45-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.general_mh" href="#Gen.general_mh"><code>Gen.general_mh</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, accepted) = general_mh(trace, proposal, proposal_args, bijection)</code></pre><p>Apply a MCMC update constructed from a bijection and a proposal that satisfies detailed balance.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/inference/mh.jl#L73-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.mala" href="#Gen.mala"><code>Gen.mala</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, accepted) = mala(trace, selection::AddressSet, tau::Real)</code></pre><p>Apply a Metropolis-Adjusted Langevin Algorithm (MALA) update.</p><p><a href="https://en.wikipedia.org/wiki/Metropolis-adjusted_Langevin_algorithm">Reference URL</a></p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/inference/mala.jl#L2-L8">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.hmc" href="#Gen.hmc"><code>Gen.hmc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, accepted) = hmc(trace, selection::AddressSet, mass=0.1, L=10, eps=0.1)</code></pre><p>Apply a Hamiltonian Monte Carlo (HMC) update.</p><p>Neal, Radford M. &quot;MCMC using Hamiltonian dynamics.&quot; Handbook of Markov Chain Monte Carlo 2.11 (2011): 2.</p><p><a href="http://www.mcmchandbook.net/HandbookChapter5.pdf">Reference URL</a></p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/inference/hmc.jl#L13-L21">source</a></section><h3><a class="nav-anchor" id="Optimization-over-Random-Choices-1" href="#Optimization-over-Random-Choices-1">Optimization over Random Choices</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.map_optimize" href="#Gen.map_optimize"><code>Gen.map_optimize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">new_trace = map_optimize(trace, selection::AddressSet, 
    max_step_size=0.1, tau=0.5, min_step_size=1e-16, verbose=false)</code></pre><p>Perform backtracking gradient ascent to optimize the log probability of the trace over selected continuous choices.</p><p>Selected random choices must have support on the entire real line.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/inference/map_optimize.jl#L1-L8">source</a></section><h3><a class="nav-anchor" id="Particle-Filtering-1" href="#Particle-Filtering-1">Particle Filtering</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.particle_filter_default" href="#Gen.particle_filter_default"><code>Gen.particle_filter_default</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(traces, log_norm_weights, lml_est) = particle_filter_default(
    model::GenerativeFunction, model_args::Tuple, num_steps::Int,
    num_particles::Int, ess_threshold::Real,
    init_observations::Assignment, step_observations::Function;
    verbose=false)</code></pre><p>Run particle filtering using the internal proposal of the model.</p><p>The first argument to the model must be an integer, starting with 1, that defines the step. The remaining arguments are given by <code>model_args</code>. The model traces will be initialized with <code>step=1</code> using the constraints given by <code>init_observations</code>. Then, the <code>step</code> will be consecutively incremented by 1. The function <code>step_observations</code> takes the step and returns a tuple <code>(observations, argdiff)</code> where <code>observations</code> is an assignment containing the values for newly observed random choices for the step, and <code>argdiff</code> describes the argument change from the previous step to the current step.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/inference/particle_filter.jl#L18-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.particle_filter_custom" href="#Gen.particle_filter_custom"><code>Gen.particle_filter_custom</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(traces, log_norm_weights, lml_est) = particle_filter_custom(
    model::GenerativeFunction, model_args::Tuple, num_steps::Int,
    num_steps::Int, num_particles::Int, ess_threshold::Real,
    init_observations::Assignment, init_proposal_args::Tuple,
    step_observations::Function, step_proposal_args::Function,
    init_proposal::GenerativeFunction, step_proposal::GenerativeFunction;
    verbose::Bool=false)</code></pre><p>Run particle filtering using custom proposal(s) at each step.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/inference/particle_filter.jl#L90-L100">source</a></section><h3><a class="nav-anchor" id="Training-Generative-Functions-1" href="#Training-Generative-Functions-1">Training Generative Functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.sgd_train_batch" href="#Gen.sgd_train_batch"><code>Gen.sgd_train_batch</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">sgd_train_batch(teacher::GenerativeFunction, teacher_args::Tuple,
    batch_student::GenerativeFunction, conf::SGDTrainConf; verbose=false)</code></pre><p>Train a batched (vectorized) student generative function on assignments sampled from a teacher generative function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/inference/train.jl#L12-L17">source</a></section><h2><a class="nav-anchor" id="Generative-Function-Interface-1" href="#Generative-Function-Interface-1">Generative Function Interface</a></h2><p>A <em>trace</em> is a record of an execution of a generative function. There is no abstract type representing all traces. Generative functions implement the <em>generative function interface</em>, which is a set of methods that involve the execution traces and probabilistic behavior of generative functions. In the mathematical description of the interface methods, we denote arguments to a function by <span>$x$</span>, complete assignments of values to addresses of random choices (containing all the random choices made during some execution) by <span>$t$</span> and partial assignments by either <span>$u$</span> or <span>$v$</span>. We denote a trace of a generative function by the tuple <span>$(x, t)$</span>. We say that two assignments <span>$u$</span> and <span>$t$</span> <em>agree</em> when they assign addresses that appear in both assignments to the same values (they can different or even disjoint sets of addresses and still agree). A generative function is associated with a family of probability distributions <span>$P(t; x)$</span> on assignments <span>$t$</span>, parameterized by arguments <span>$x$</span>, and a second family of distributions <span>$Q(t; u, x)$</span> on assignments <span>$t$</span> parameterized by partial assignment <span>$u$</span> and arguments <span>$x$</span>. <span>$Q$</span> is called the <em>internal proposal family</em> of the generative function, and satisfies that if <span>$u$</span> and <span>$t$</span> agree then <span>$P(t; x) &gt; 0$</span> if and only if <span>$Q(t; x, u) &gt; 0$</span>, and that <span>$Q(t; x, u) &gt; 0$</span> implies that <span>$u$</span> and <span>$t$</span> agree. See the <a href="http://hdl.handle.net/1721.1/119255">Gen technical report</a> for additional details.</p><p>Generative functions may also use <em>non-addressable random choices</em>, denoted <span>$r$</span>. Unlike regular (addressable) random choices, non-addressable random choices do not have addresses, and the value of non-addressable random choices is not exposed through the generative function interface. However, the state of non-addressable random choices is maintained in the trace. A trace that contains non-addressable random choices is denoted <span>$(x, t, r)$</span>. Non-addressable random choices manifest to the user of the interface as stochasticity in weights returned by generative function interface methods. The behavior of non-addressable random choices is defined by an additional pair of families of distributions associated with the generative function, denoted <span>$Q(r; x, t)$</span> and <span>$P(r; x, t)$</span>, which are defined for <span>$P(t; x) &gt; 0$</span>, and which satisfy <span>$Q(r; x, t) &gt; 0$</span> if and only if <span>$P(r; x, t) &gt; 0$</span>. For each generative function below, we describe its semantics first in the basic setting where there is no non-addressable random choices, and then in the more general setting that may include non-addressable random choices.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.initialize" href="#Gen.initialize"><code>Gen.initialize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(trace::U, weight) = initialize(gen_fn::GenerativeFunction{T,U}, args::Tuple,
                                assmt::Assignment)</code></pre><p>Return a trace of a generative function that is consistent with the given assignment.</p><p><strong>Basic case</strong></p><p>Given arguments <span>$x$</span> (<code>args</code>) and assignment <span>$u$</span> (<code>assmt</code>), sample <span>$t \sim Q(\cdot; u, x)$</span> and return the trace <span>$(x, t)$</span> (<code>trace</code>).  Also return the weight (<code>weight</code>):</p><div>\[\frac{P(t; x)}{Q(t; u, x)}\]</div><p><strong>General case</strong></p><p>Identical to the basic case, except that we also sample <span>$r \sim Q(\cdot; x, t)$</span>, the trace is <span>$(x, t, r)$</span> and the weight is:</p><div>\[\frac{P(t; x)}{Q(t; u, x)}
\cdot \frac{P(r; x, t)}{Q(r; x, t)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/gen_fn_interface.jl#L70-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.project" href="#Gen.project"><code>Gen.project</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">weight = project(trace::U, selection::AddressSet)</code></pre><p>Estimate the probability that the selected choices take the values they do in a trace. </p><p><strong>Basic case</strong></p><p>Given a trace <span>$(x, t)$</span> (<code>trace</code>) and a set of addresses <span>$A$</span> (<code>selection</code>), let <span>$u$</span> denote the restriction of <span>$t$</span> to <span>$A$</span>. Return the weight (<code>weight</code>):</p><div>\[\frac{P(t; x)}{Q(t; u, x)}\]</div><p><strong>General case</strong></p><p>Identical to the basic case except that the previous trace is <span>$(x, t, r)$</span> and the weight is:</p><div>\[\frac{P(t; x)}{Q(t; u, x)}
\cdot \frac{P(r; x, t)}{Q(r; x, t)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/gen_fn_interface.jl#L104-L127">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.propose" href="#Gen.propose"><code>Gen.propose</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(assmt, weight, retval) = propose(gen_fn::GenerativeFunction, args::Tuple)</code></pre><p>Sample an assignment and compute the probability of proposing that assignment.</p><p><strong>Basic case</strong></p><p>Given arguments (<code>args</code>), sample <span>$t&#39; \sim P(\cdot; x)$</span>, and return <span>$t$</span> (<code>assmt</code>) and the weight (<code>weight</code>) <span>$P(t; x)$</span>.</p><p><strong>General case</strong></p><p>Identical to the basic case, except that we also sample <span>$r \sim P(\cdot; x, t)$</span>, and the weight is:</p><div>\[P(t; x)
\cdot \frac{P(r; x, t)}{Q(r; x, t)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/gen_fn_interface.jl#L132-L150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.assess" href="#Gen.assess"><code>Gen.assess</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(weight, retval) = assess(gen_fn::GenerativeFunction, args::Tuple, assmt::Assignment)</code></pre><p>Return the probability of proposing an assignment</p><p><strong>Basic case</strong></p><p>Given arguments <span>$x$</span> (<code>args</code>) and an assignment <span>$t$</span> (<code>assmt</code>) such that <span>$P(t; x) &gt; 0$</span>, return the weight (<code>weight</code>) <span>$P(t; x)$</span>.  It is an error if <span>$P(t; x) = 0$</span>.</p><p><strong>General case</strong></p><p>Identical to the basic case except that we also sample <span>$r \sim Q(\cdot; x, t)$</span>, and the weight is:</p><div>\[P(t; x)
\cdot \frac{P(r; x, t)}{Q(r; x, t)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/gen_fn_interface.jl#L155-L174">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.force_update" href="#Gen.force_update"><code>Gen.force_update</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, weight, discard, retdiff) = force_update(args::Tuple, argdiff, trace,
                                                     assmt::Assignment)</code></pre><p>Update a trace by changing the arguments and/or providing new values for some existing random choice(s) and values for any newly introduced random choice(s).</p><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>), new arguments <span>$x&#39;$</span> (<code>args</code>), and an assignment <span>$u$</span> (<code>assmt</code>), return a new trace <span>$(x&#39;, t&#39;)$</span> (<code>new_trace</code>) that is consistent with <span>$u$</span>.  The values of choices in <span>$t&#39;$</span> are deterministically copied either from <span>$t$</span> or from <span>$u$</span> (with <span>$u$</span> taking precedence).  All choices in <span>$u$</span> must appear in <span>$t&#39;$</span>.  Also return an assignment <span>$v$</span> (<code>discard</code>) containing the choices in <span>$t$</span> that were overwritten by values from <span>$u$</span>, and any choices in <span>$t$</span> whose address does not appear in <span>$t&#39;$</span>.  Also return the weight (<code>weight</code>):</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)}\]</div><p><strong>General case</strong></p><p>Identical to the basic case except that the previous trace is <span>$(x, t, r)$</span>, the new trace is <span>$(x&#39;, t&#39;, r&#39;)$</span> where <span>$r&#39; \sim Q(\cdot; x&#39;, t&#39;)$</span>, and the weight is:</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)}
\cdot \frac{P(r&#39;; x&#39;, t&#39;) Q(r; x, t)}{P(r; x, t) Q(r&#39;; x&#39;, t&#39;)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/gen_fn_interface.jl#L180-L210">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.fix_update" href="#Gen.fix_update"><code>Gen.fix_update</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, weight, discard, retdiff) = fix_update(args::Tuple, argdiff, trace,
                                                   assmt::Assignment)</code></pre><p>Update a trace, by changing the arguments and/or providing new values for some existing random choice(s).</p><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>), new arguments <span>$x&#39;$</span> (<code>args</code>), and an assignment <span>$u$</span> (<code>assmt</code>), return a new trace <span>$(x&#39;, t&#39;)$</span> (<code>new_trace</code>) that is consistent with <span>$u$</span>.  Let <span>$u + t$</span> denote the merge of <span>$u$</span> and <span>$t$</span> (with <span>$u$</span> taking precedence).  Sample <span>$t&#39; \sim Q(\cdot; u + t, x)$</span>. All addresses in <span>$u$</span> must appear in <span>$t$</span> and in <span>$t&#39;$</span>.  Also return an assignment <span>$v$</span> (<code>discard</code>) containing the values from <span>$t$</span> for addresses in <span>$u$</span>.  Also return the weight (<code>weight</code>):</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)} \cdot \frac{Q(t; v + t&#39;, x)}{Q(t&#39;; u + t, x&#39;)}\]</div><p><strong>General case</strong></p><p>Identical to the basic case except that the previous trace is <span>$(x, t, r)$</span>, the new trace is <span>$(x&#39;, t&#39;, r&#39;)$</span> where <span>$r&#39; \sim Q(\cdot; x&#39;, t&#39;)$</span>, and the weight is:</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)}
\cdot \frac{Q(t; v + t&#39;, x)}{Q(t&#39;; u + t, x&#39;)}
\cdot \frac{P(r&#39;; x&#39;, t&#39;) Q(r; x, t)}{P(r; x, t) Q(r&#39;; x&#39;, t&#39;)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/gen_fn_interface.jl#L215-L245">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.free_update" href="#Gen.free_update"><code>Gen.free_update</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, weight, retdiff) = free_update(args::Tuple, argdiff, trace,
                                           selection::AddressSet)</code></pre><p>Update a trace by changing the arguments and/or randomly sampling new values for selected random choices.</p><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>), new arguments <span>$x&#39;$</span> (<code>args</code>), and a set of addresses <span>$A$</span> (<code>selection</code>), return a new trace <span>$(x&#39;, t&#39;)$</span> (<code>new_trace</code>) such that <span>$t&#39;$</span> agrees with <span>$t$</span> on all addresses not in <span>$A$</span> (<span>$t$</span> and <span>$t&#39;$</span> may have different sets of addresses).  Let <span>$u$</span> denote the restriction of <span>$t$</span> to the complement of <span>$A$</span>.  Sample <span>$t&#39; \sim Q(\cdot; u, x&#39;)$</span>.  Return the new trace <span>$(x&#39;, t&#39;)$</span> (<code>new_trace</code>) and the weight (<code>weight</code>):</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)}
\cdot \frac{Q(t; u&#39;, x)}{Q(t&#39;; u, x&#39;)}\]</div><p>where <span>$u&#39;$</span> is the restriction of <span>$t&#39;$</span> to the complement of <span>$A$</span>.</p><p><strong>General case</strong></p><p>Identical to the basic case except that the previous trace is <span>$(x, t, r)$</span>, the new trace is <span>$(x&#39;, t&#39;, r&#39;)$</span> where <span>$r&#39; \sim Q(\cdot; x&#39;, t&#39;)$</span>, and the weight is:</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x)}
\cdot \frac{Q(t; u&#39;, x)}{Q(t&#39;; u, x&#39;)}
\cdot \frac{P(r&#39;; x&#39;, t&#39;) Q(r; x, t)}{P(r; x, t) Q(r&#39;; x&#39;, t&#39;)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/gen_fn_interface.jl#L250-L282">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.extend" href="#Gen.extend"><code>Gen.extend</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(new_trace, weight, retdiff) = extend(args::Tuple, argdiff, trace, assmt::Assignment)</code></pre><p>Extend a trace with new random choices by changing the arguments.</p><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>), new arguments <span>$x&#39;$</span> (<code>args</code>), and an assignment <span>$u$</span> (<code>assmt</code>) that shares no addresses with <span>$t$</span>, return a new trace <span>$(x&#39;, t&#39;)$</span> (<code>new_trace</code>) such that <span>$t&#39;$</span> agrees with <span>$t$</span> on all addresses in <span>$t$</span> and <span>$t&#39;$</span> agrees with <span>$u$</span> on all addresses in <span>$u$</span>. Sample <span>$t&#39; \sim Q(\cdot; t + u, x&#39;)$</span>. Also return the weight (<code>weight</code>):</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x) Q(t&#39;; t + u, x&#39;)}\]</div><p><strong>General case</strong></p><p>Identical to the basic case except that the previous trace is <span>$(x, t, r)$</span>, and we also sample <span>$r&#39; \sim Q(\cdot; t&#39;, x)$</span>, the new trace is <span>$(x&#39;, t&#39;, r&#39;)$</span>, and the weight is:</p><div>\[\frac{P(t&#39;; x&#39;)}{P(t; x) Q(t&#39;; t + u, x&#39;)}
\cdot \frac{P(r&#39;; x&#39;, t&#39;) Q(r; x, t)}{P(r; x, t) Q(r&#39;; x&#39;, t&#39;)}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/gen_fn_interface.jl#L287-L312">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.backprop_params" href="#Gen.backprop_params"><code>Gen.backprop_params</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">arg_grads = backprop_params(trace, retgrad)</code></pre><p>Increment gradient accumulators for parameters by the gradient of the log-probability of the trace.</p><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>) and a gradient with respect to the return value <span>$∇_y J$</span> (<code>retgrad</code>), return the following gradient (<code>arg_grads</code>) with respect to the arguments <span>$x$</span>:</p><div>\[∇_x \left( \log P(t; x) + J \right)\]</div><p>Also increment the gradient accumulators for the static parameters <span>$Θ$</span> of the function by:</p><div>\[∇_Θ \left( \log P(t; x) + J \right)\]</div><p><strong>General case</strong></p><p>Not yet formalized.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/gen_fn_interface.jl#L317-L340">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.backprop_trace" href="#Gen.backprop_trace"><code>Gen.backprop_trace</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">(arg_grads, choice_values, choice_grads) = backprop_trace(trace, selection::AddressSet,
                                                          retgrad)</code></pre><p><strong>Basic case</strong></p><p>Given a previous trace <span>$(x, t)$</span> (<code>trace</code>) and a gradient with respect to the return value <span>$∇_y J$</span> (<code>retgrad</code>), return the following gradient (<code>arg_grads</code>) with respect to the arguments <span>$x$</span>:</p><div>\[∇_x \left( \log P(t; x) + J \right)\]</div><p>Also given a set of addresses <span>$A$</span> (<code>selection</code>) that are continuous-valued random choices, return the folowing gradient (<code>choice_grads</code>) with respect to the values of these choices:</p><div>\[∇_A \left( \log P(t; x) + J \right)\]</div><p>Also return the assignment (<code>choice_values</code>) that is the restriction of <span>$t$</span> to <span>$A$</span>.</p><p><strong>General case</strong></p><p>Not yet formalized.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/gen_fn_interface.jl#L345-L368">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_assmt" href="#Gen.get_assmt"><code>Gen.get_assmt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_assmt(trace)</code></pre><p>Return a value implementing the assignment interface</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/gen_fn_interface.jl#L19-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_args" href="#Gen.get_args"><code>Gen.get_args</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_args(trace)</code></pre><p>Return the argument tuple for a given execution.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/gen_fn_interface.jl#L5-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_retval" href="#Gen.get_retval"><code>Gen.get_retval</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_retval(trace)</code></pre><p>Return the return value of the given execution.</p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/gen_fn_interface.jl#L12-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Gen.get_score" href="#Gen.get_score"><code>Gen.get_score</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_score(trace)</code></pre><p><strong>Basic case</strong></p><p>Return <span>$P(t; x)$</span></p><p><strong>General case</strong></p><p>Return <span>$P(r, t; x) / Q(r; tx, t)$</span></p></div></div><a class="source-link" target="_blank" href="https://github.com/probcomp/Gen/blob/159dd8e037fdace9021a87a53ec882ee5ef4bc1c/src/gen_fn_interface.jl#L26-L36">source</a></section><footer><hr/><a class="previous" href="../guide/"><span class="direction">Previous</span><span class="title">Guide</span></a></footer></article></body></html>
