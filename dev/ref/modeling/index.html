<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Modeling Languages · Gen</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Gen</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../getting_started/">Getting Started</a></li><li><a class="toctext" href="../../tutorials/">Tutorials</a></li><li><a class="toctext" href="../../guide/">Guide</a></li><li><span class="toctext">Reference</span><ul><li class="current"><a class="toctext" href>Modeling Languages</a><ul class="internal"><li><a class="toctext" href="#Dynamic-DSL-1">Dynamic DSL</a></li><li><a class="toctext" href="#Static-DSL-1">Static DSL</a></li></ul></li><li><a class="toctext" href="../combinators/">Generative Function Combinators</a></li><li><a class="toctext" href="../assignments/">Assignments</a></li><li><a class="toctext" href="../selections/">Selections</a></li><li><a class="toctext" href="../inference/">Inference Library</a></li><li><a class="toctext" href="../gfi/">Generative Function Interface</a></li><li><a class="toctext" href="../distributions/">Probability Distributions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Reference</li><li><a href>Modeling Languages</a></li></ul><a class="edit-page" href="https://github.com/probcomp/Gen/blob/master/docs/src/ref/modeling.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Modeling Languages</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Modeling-Languages-1" href="#Modeling-Languages-1">Modeling Languages</a></h1><p>Gen provides two embedded DSLs for defining generative functions. Both DSLs are based on Julia function definition syntax.</p><h2><a class="nav-anchor" id="Dynamic-DSL-1" href="#Dynamic-DSL-1">Dynamic DSL</a></h2><p><em>Dynamic DSL</em> functions are defined using the <code>@gen</code> macro in front of a Julia function definition. We will refer to Dynamic DSL functions as &#39;<code>@gen</code> functions&#39; from here forward.</p><p>Here is an example <code>@gen</code> function that samples two random choices:</p><pre><code class="language-julia">@gen function foo(prob::Float64)
    z1 = @addr(bernoulli(prob), :a)
    z2 = @addr(bernoulli(prob), :b)
    return z1 || z2
end</code></pre><p>After running this code, <code>foo</code> is a Julia value of type <code>DynamicDSLFunction</code>, which is a subtype of <code>GenerativeFunction</code>.</p><h3><a class="nav-anchor" id="Making-random-choices-1" href="#Making-random-choices-1">Making random choices</a></h3><p>Random choices are made by applying a probability distribution to some arguments:</p><pre><code class="language-julia">val::Bool = bernoulli(0.5)</code></pre><p>See <a href="../distributions/#Probability-Distributions-1">Probability Distributions</a> for the set of built-in probability distributions. Within the context of a <code>@gen</code> function, wrapping the right-hand side of the expression associates the random choice with an <em>address</em>, and evaluates to the value of the random choice. Addresses can be any Julia value. Here, we give the Julia symbol address <code>:z</code>:</p><pre><code class="language-julia">val::Bool = @addr(bernoulli(0.5), :z)</code></pre><p>Not all random choices need to be given addresses. An address is required if the random choice will be observed, or will be referenced by a custom inference algorithm (e.g. if it will be proposed to by a custom proposal distribution).</p><p>It is recommended to ensure that the support of a random choice at a given address (the set of values with nonzero probability or probability density) is constant across all possible executions of the generative function. This discipline will simplify reasoning about the probabilistic behavior of the function, and will help avoid difficult-to-debug NaNs or Infs from appearing. If the support of a random choice needs to change, consider using a different address for each distinct support.</p><h3><a class="nav-anchor" id="Calling-generative-functions-1" href="#Calling-generative-functions-1">Calling generative functions</a></h3><p><code>@gen</code> functions can invoke other generative functions in three ways:</p><p><strong>Untraced call</strong>: If <code>foo</code> is a generative function, we can invoke <code>foo</code> from within the body of a <code>@gen</code> function using regular call syntax. The random choices made within the call are not given addresses in our trace, and are therefore <em>non-addressable</em> random choices (see <a href="ref/@ref">Generative Function Interface</a> for details on non-addressable random choices).</p><pre><code class="language-julia">val = foo(0.5)</code></pre><p><strong>Traced call with shared address namespace</strong>: We can include the addressable random choices made by <code>foo</code> in the caller&#39;s trace using <code>@splice</code>:</p><pre><code class="language-julia">val = @splice(foo(0.5))</code></pre><p>Now, all random choices made by <code>foo</code> are included in our trace. The caller must guarantee that there are no address collisions.</p><p><strong>Traced call with a nested address namespace</strong>: We can include the addressable random choices made by <code>foo</code> in the caller&#39;s trace, under a namespace, using <code>@addr</code>:</p><pre><code class="language-julia">val = @addr(foo(0.5), :x)</code></pre><p>Now, all random choices made by <code>foo</code> are included in our trace, under the namespace <code>:x</code>. For example, if <code>foo</code> makes random choices at addresses <code>:a</code> and <code>:b</code>, these choices will have addresses <code>:x =&gt; :a</code> and <code>:x =&gt; :b</code> in the caller&#39;s trace.</p><h3><a class="nav-anchor" id="Using-composite-addresses-1" href="#Using-composite-addresses-1">Using composite addresses</a></h3><p>In Julia, <code>Pair</code> values can be constructed using the <code>=&gt;</code> operator. For example, <code>:a =&gt; :b</code> is equivalent to <code>Pair(:a, :b)</code> and <code>:a =&gt; :b =&gt; :c</code> is equivalent to <code>Pair(:a, Pair(:b, :c))</code>. A <code>Pair</code> value (e.g. <code>:a =&gt; :b =&gt; :c</code>) can be passed as the address field in an <code>@addr</code> expression, provided that there is not also a random choice or generative function called with <code>@addr</code> at any prefix of the address.</p><p>Consider the following examples.</p><p>This example is <strong>invalid</strong> because <code>:a =&gt; :b</code> is a prefix of <code>:a =&gt; :b =&gt; :c</code>:</p><pre><code class="language-julia">@addr(normal(0, 1), :a =&gt; :b =&gt; :c)
@addr(normal(0, 1), :a =&gt; :b)</code></pre><p>This example is <strong>invalid</strong> because <code>:a</code> is a prefix of <code>:a =&gt; :b =&gt; :c</code>:</p><pre><code class="language-julia">@addr(normal(0, 1), :a =&gt; :b =&gt; :c)
@addr(normal(0, 1), :a)</code></pre><p>This example is <strong>invalid</strong> because <code>:a =&gt; :b</code> is a prefix of <code>:a =&gt; :b =&gt; :c</code>:</p><pre><code class="language-julia">@addr(normal(0, 1), :a =&gt; :b =&gt; :c)
@addr(foo(0.5), :a =&gt; :b)</code></pre><p>This example is <strong>invalid</strong> because <code>:a</code> is a prefix of <code>:a =&gt; :b</code>:</p><pre><code class="language-julia">@addr(normal(0, 1), :a)
@addr(foo(0.5), :a =&gt; :b)</code></pre><p>This example is <strong>valid</strong> because <code>:a =&gt; :b</code> and <code>:a =&gt; :c</code> are not prefixes of one another:</p><pre><code class="language-julia">@addr(normal(0, 1), :a =&gt; :b)
@addr(normal(0, 1), :a =&gt; :c)</code></pre><p>This example is <strong>valid</strong> because <code>:a =&gt; :b</code> and <code>:a =&gt; :c</code> are not prefixes of one another:</p><pre><code class="language-julia">@addr(normal(0, 1), :a =&gt; :b)
@addr(foo(0.5), :a =&gt; :c)</code></pre><h3><a class="nav-anchor" id="Return-value-1" href="#Return-value-1">Return value</a></h3><p>Like regular Julia functions, <code>@gen</code> functions return either the expression used in a <code>return</code> keyword, or by evaluating the last expression in the function body. Note that the return value of a <code>@gen</code> function is different from a trace of <code>@gen</code> function, which contains the return value associated with an execution as well as the assignment to each random choice made during the execution. See <a href="ref/@ref">Generative Function Interface</a> for more information about traces.</p><h2><a class="nav-anchor" id="Static-DSL-1" href="#Static-DSL-1">Static DSL</a></h2><p><em>Static DSL</em> functions are defined using the <code>@staticgen</code> macro. We will refer to Static DSL functions as &#39;<code>@staticgen</code> functions&#39; from here forward.</p><p>Here is an example <code>@staticgen</code> function that samples two random choices:</p><pre><code class="language-julia">@staticgen function foo(prob::Float64)
    z1 = @addr(bernoulli(prob), :a)
    z2 = @addr(bernoulli(prob), :b)
    z3 = z1 || z2
    return z3
end</code></pre><p>After running this code, <code>foo</code> is a Julia value whose type is a subtype of <code>StaticIRGenerativeFunction</code>, which is a subtype of <code>GenerativeFunction</code>.</p><p>The Static DSL permits a subset of the syntax permitted by the Dynamic DSL. In particular, each statement must be one of the following forms:</p><ul><li><p><code>&lt;symbol&gt; = &lt;julia-expr&gt;</code></p></li><li><p><code>&lt;symbol&gt; = @addr(&lt;dist|gen-fn&gt;(..),&lt;symbol&gt; [ =&gt; ..])</code></p></li><li><p><code>@addr(&lt;dist|gen-fn&gt;(..),&lt;symbol&gt; [ =&gt; ..])</code></p></li><li><p><code>return &lt;symbol&gt;</code></p></li></ul><p>Note that the <code>@addr</code> keyword may only appear in at the top-level of the right-hand-side expresssion. Also, addresses used with the <code>@addr</code> keyword must be a literal Julia symbol (e.g. <code>:a</code>). If multi-part addresses are used, the first component in the multi-part address must be a literal Julia symbol (e.g. <code>:a =&gt; i</code> is valid).</p><p>Also, symbols used on the left-hand-side of assignment statements must be unique (this is called &#39;static single assignment&#39; (SSA) form) (this is called &#39;static single-assignment&#39; (SSA) form).</p><h3><a class="nav-anchor" id="Loading-generated-functions-1" href="#Loading-generated-functions-1">Loading generated functions</a></h3><p>Before a <code>@staticgen</code> function can be invoked at runtime, <code>Gen.load_generated_functions()</code> method must be called. Typically, this call immediately preceeds the execution of the inference algorithm.</p><h3><a class="nav-anchor" id="Performance-tips-1" href="#Performance-tips-1">Performance tips</a></h3><p>For better performance, annotate the left-hand side of random choices with the type. This permits a more optimized trace data structure to be generated for the generative function. For example:</p><pre><code class="language-julia">@staticgen function foo(prob::Float64)
    z1::Bool = @addr(bernoulli(prob), :a)
    z2::Bool = @addr(bernoulli(prob), :b)
    z3 = z1 || z2
    return z3
end</code></pre><footer><hr/><a class="previous" href="../../guide/"><span class="direction">Previous</span><span class="title">Guide</span></a><a class="next" href="../combinators/"><span class="direction">Next</span><span class="title">Generative Function Combinators</span></a></footer></article></body></html>
