\documentclass{article}
\usepackage[usenames,dvipsnames,svgnames]{xcolor}
\usepackage[utf8]{inputenc}
\usepackage{algpseudocode}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{algorithm}
\usepackage{tikz}
\usepackage{subcaption}
\usepackage{fancyvrb}
\usepackage{bm}
\usepackage{textcomp}
\usepackage{listings}
\usepackage{todonotes}
\usepackage{mathtools} % long right arrow
\usepackage{proof} % for infer
\usepackage{setspace} % set line spacing
\usepackage{amsthm}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}{Definition}[section]

\newcommand{\code}[1]{\texttt{\small{\textbf{#1}}}}
\newcommand{\reals}[0]{\mathbb{R}}
\newcommand{\naturals}[0]{\mathbb{N}}
\newcommand{\integers}[0]{\mathbb{Z}}
\newcommand{\rationals}[0]{\mathbb{Q}}
\newcommand\doubleplus{\mathbin{+\mkern-5mu+}}
\newcommand{\concat}[0]{\doubleplus}
\newcommand{\diff}[0]{\setminus}
\newcommand{\dom}[1]{\mbox{dom}{~#1}}

\title{Gen Semantics}
\author{Marco Cusumano-Towner}

\begin{document}

\maketitle

\section{Traces}
A \emph{trace} is a finite map from addresses to values, which for simplicity, we are elements of some discrete set $V$.
For traces $s$ and $t$ with disjoint domains $\dom{s}$ and $\dom{t}$, let $u = s \concat t$ denote the trace where $u(i) = s(i)$ for $i \in \dom{s}$ and $u(i) = t(i)$ for $i \in \dom{t}$.
For two traces $s$ and $t$, let $s \le t$ denote the relation that $\dom{s} \subseteq \dom{t}$ and that $s(i) = t(i)$ for all $i \in \dom{s}$.
For $s \le t$, let $u = t \diff s$ denote the trace with $u(i) = s(i)$ for each $i \in \dom{t} \setminus \dom{s}$.
Let $t|_S$ denote the restriction of a trace $t$ to a set $S$ of addresses.

\section{Probabilistic Module}
A \emph{probabilistic module} is a tuple $(X, p, U, q_{gen}, q_{fix}, q_{free}, \theta, f)$, where $X$ is the set of valid \emph{inputs} to the module, and where $p$, $q_{gen}$ and $q_{fix}$, $q_{free}$ are indexed sets of probability distribution on traces, where $\theta$ are current parameters of the module (upon which $p$ has an implicit dependence).
Specifically, $p(t; x) \ge 0$ where $t$ is a trace, and where $x \in X$ and $\sum_t p(t; x) = 1$ for all $x \in X$.
$p(t; x)$ is the probability of a trace given input $x$.
Let $T_x = \{t : p(t; x) > 0 \}$ denote the set of \emph{possible traces} for input $x \in X$.
The function $f : \{(x, t) : x \in X, t \in T_x\} \to Y$ defines the \emph{output value} $y \in Y$ given the inputs and a trace.

% TODO all of the methods will accept arbitary configuration, which is
% recursively dispatched throughout the call hierarchy during calls to methods.
% the address selection is one example type of configuration used to configure
% free_update.

\paragraph{Generate (\code{generate})}
Let $U_x$ denote a set of traces, called \emph{valid generation constraints}, such that for each $u \in U_x$ there exists some $t \in T_x$ where $u \le t$.
Note that $U_x$ need not include all such $u$ (i.e. $U_x$ is not necessarily the set of all projections of all traces in $T_x$).
Then, for each $x \in X, u \in U_x$, we require that $q_{gen}(s; u, x) > 0$ if and only if $s = t \diff u$ for some $t \in T_x$, and $\sum_s q_{gen}(s; u, x) = 1$.
Take as input $x \in X$, $u \in U_x$, and sample $s \sim q_{gen}(\cdot; u, x)$, and return $t = s \concat u$ and a weight $p(t; x) / q(s; u, x)$.
Also return $y = f(x, t)$.

%\paragraph{Propose (\code{propose})}
%Given $x \in X$ and a set of addresses $S$, sample a trace $t \sim p(\cdot; x)$, and return 
% TODO

\paragraph{Force Update (\code{force\_update})}
Given $x, x' \in X$ and a trace $t \in T_x$, and a trace $u$ such that $t' = u \concat (t \setminus u) \in T_{x'}$, return $t'$, a weight $p(t'; x') / p(t; x)$, and a \emph{discard trace} $v(i) = t(i)$ for $i \in (\dom{t} \cap \dom{u}) \cup (\dom{t} \setminus \dom{u}) \to V$ where $v(i) = t(i)$.
Also return $y' = f(x', t')$.

\paragraph{Fix Update (\code{fix\_update})}
Given $x, x' \in X$ and $t \in T_x$, and trace $u$ such that $\dom(u) \subseteq \dom(t)$, $D_{x,x',t,u} \subseteq \dom(t') \setminus \dom(u)$ is a set of \emph{deleted addresses}, and $q_{fix}(s; t, x, x', u)$ is an indexed set of probability distributions on traces $s$, such that $q_{fix}(s; t, x, x', u) > 0$ implies that $\dom(s) \cap \dom(u) = \varnothing$ and $t' = s \concat u \concat (t|_{D_{x,x',t,u}^C}) \in T_{x'}$ and $q_{fix}(s'; t', x', x, v) > 0$ where $v(i) = t(i)$ for $i \in \dom(u)$, and $t = s' \concat v \concat (t' |_{D_{x',x,v,t'}^C})$.
Sample $s \sim q_{fix}(\cdot; t, x, x', u)$ and return $t'$, the \emph{discard trace} $v$, and the weight:
\[
\frac{p(t'; x')}{p(t; x)} \frac{q_{fix}(s'; t', x', x, v)}{q_{fix}(s; t, x, x', u)}
\]
Also return $y' = f(x', t')$.

\paragraph{Free Update (\code{free\_update})}
Given $x, x' \in X$, and $t \in T_x$, $q_{free}(t'; t, x, x')$ is a distribution on traces such that $q_{free}(t'; t, x, x') > 0$ implies $t' \in T_{x'}$, and such that $q_{free}(t'; t, x, x') > 0$ implies $q_{free}(t; t', x', x) > 0$.
Sample $t' \sim q_{free}(\cdot; t, x, x')$ and return $t'$, and a weight:
\[
    \frac{p(t'; x')}{p(t; x)} \frac{q_{free}(t; t', x', x)}{q_{free}(t'; t, x, x')}
\]
Also return $y' = f(x', t')$.
Note that `regenerate', where we provide a set of addresses that should be resimulated, is an example of this.

\paragraph{Backpropagate to Parameters (\code{backprop\_params})}
Given $x \in X$ and $t \in T_x$, and $\nabla_y J$, return $\nabla_x (J + \log p(t; x))$ and $\nabla_{\theta} (J + \log p(t; x))$.

% \paragraph{Backpropagate to Trace (\code{backprop\_trace})}
% TODO doesn't make sense if values come from a discrete set

Each probabilistic module may also possess an indexed collection of families of distributions for use in \code{generate} and \code{update}.
Probabilistic modules may also have update procedures that make arbitrary changes to their trace, and return the appropriate weight.
These two features are not yet implemented.

\section{Untraced Random Choices}

\section{Generative Functions}
% an example of a probabilistic module that is composed of other probabilistic modules.
% give implementations of these various things (as small step semantics?)

\clearpage
\bibliographystyle{abbrv}
\bibliography{references}

\end{document}
